<!DOCTYPE html>
<html>
<head>
  <title>Content Encryption Tool v19</title>
  <style>
    /* ... (styles) ... */ 
  </style>
</head>
<body>
  <div id="encryptionTool">
    <h2>Content Encryption Tool v19</h2>

    <label for="inputKey">Encryption Key:</label>
    <input type="text" id="inputKey" value="">
    <p id="keyHash"></p>

    <label for="inputContent">Content to Encrypt:</label>
    <textarea id="inputContent"></textarea>

    <label for="outputContent">Encrypted Content:</label>
    <textarea id="outputContent" readonly></textarea>

    <label for="decryptedContent">Decrypted Content (for verification):</label>
    <textarea id="decryptedContent" readonly></textarea>

    <p id="statusMessage"></p>
  </div>

  <script>
    document.title = document.title.replace(/\d+$/, match => ++match);
    (async (inputKey, inputContent, outputContent, decryptedContent, keyHashDisplay, statusMessage, encoder = new TextEncoder()) => {
        async function displayKeyHash(key) {
            if (key.trim() !== '') {
                const hashedKey = await encryptInput(key);
                console.log("SHA-256 Hash of Key:", hashedKey); // Log the hashed key
                keyHashDisplay.textContent = hashedKey; 
            }
        }
        async function encryptContent(content, key) { 
            console.log("Original Content Length:", content.length);

            const data = encoder.encode(content);
            const iv = window.crypto.getRandomValues(new Uint8Array(12)); 
            const keyMaterial = await crypto.subtle.importKey("raw", encoder.encode(key), { name: "PBKDF2" }, false, ["deriveKey"]);
            const derivedKey = await crypto.subtle.deriveKey({ name: "PBKDF2", salt: new Uint8Array(), iterations: 100000, hash: "SHA-256" }, keyMaterial, { name: "AES-GCM", length: 256 }, false, ["encrypt", "decrypt"]);
            const encrypted = await window.crypto.subtle.encrypt({ name: "AES-GCM", iv }, derivedKey, data);

            const encryptedData = new Uint8Array(encrypted);
            const combined = new Uint8Array(iv.length + encryptedData.length);
            combined.set(iv);
            combined.set(encryptedData, iv.length);
            const base64Encoded = btoa(String.fromCharCode.apply(null, combined));
            
            console.log("Encrypted Content:", base64Encoded);
            return base64Encoded; 
        }
        async function decryptContent(encryptedContent, key) { 
            console.log("Decrypting content:", encryptedContent);
            const keyData = encoder.encode(key);
            const combined = new Uint8Array(atob(encryptedContent).split('').map(char => char.charCodeAt(0)));
            const iv = combined.slice(0, 12);
            const ciphertext = combined.slice(12);
            const keyMaterial = await crypto.subtle.importKey("raw", encoder.encode(key), { name: "PBKDF2" }, false, ["deriveKey"]);
            const derivedKey = await crypto.subtle.deriveKey({ name: "PBKDF2", salt: new Uint8Array(), iterations: 100000, hash: "SHA-256" }, keyMaterial, { name: "AES-GCM", length: 256 }, false, ["encrypt", "decrypt"]);
            const decrypted = await crypto.subtle.decrypt({ name: "AES-GCM", iv: iv }, derivedKey, ciphertext);
            const decryptedText = new TextDecoder().decode(decrypted);
            console.log("Decrypted content:", decryptedText);
            return decryptedText; 
        }

        function updateEncryptedContent() { 
            const content = inputContent.value; 
            const key = inputKey.value;
            if (key.trim() === '') { statusMessage.textContent = "Please enter an encryption key."; return; }
            displayKeyHash(); 
            encryptContent(content, key)
                .then(async (encrypted) => {
                    outputContent.value = encrypted;
                    try {
                        const decrypted = await decryptContent(encrypted, inputKey.value);
                        decryptedContent.value = decrypted;
                        statusMessage.textContent = "Encryption/Decryption successful!"; 
                    } catch (error) {
                        console.error('Decryption error:', error);
                        statusMessage.textContent = "Error: Decryption failed.";
                    }
                })
                .catch(error => {
                    console.error('Encryption error:', error);
                    outputContent.value = "Error encrypting content";
                });
        }

        inputKey.addEventListener('input', updateEncryptedContent);
        inputContent.addEventListener('input', updateEncryptedContent);
        outputContent.addEventListener('click', () => { outputContent.select(); document.execCommand('copy'); });
        setTimeout(updateEncryptedContent, 500); 
    })(
      document.getElementById('inputKey'),
      document.getElementById('inputContent'),
      document.getElementById('outputContent'),
      document.getElementById('decryptedContent'),
      document.getElementById('keyHash'),
      document.getElementById('statusMessage')
    );
  </script>
</body>
</html>
